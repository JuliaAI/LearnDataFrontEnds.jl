var documenterSearchIndex = {"docs":
[{"location":"quick_start/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Supervised regressors\nSupervised classifiers\nTransformers","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Refer to the front end [docstrings](@ref front_ends) for options ignored below.","category":"page"},{"location":"quick_start/#Supervised-regressors","page":"Quick start","title":"Supervised regressors","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Supervised regressors handling structured data can typically add the Saffron front end to their LearnAPI.jl implementations.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For a supervised learner of type MyLearner, with LearnAPI.fit(::MyLearner, data) returning objects of type MyModel, make these declarations:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using LearnDataFrontEnds\nconst frontend = Saffron()\n\n# both methods below return objects with abstract type `Obs`:\nLearnAPI.obs(learner::MyLearner, data) = fitobs(learner, data, frontend)\nLearnAPI.obs(model::MyModel, data) = obs(model, data, frontend)\n\n# training data deconstructors:\nLearnAPI.features(learner::MyLearner, data) = LearnAPI.features(learner, data, frontend)\nLearnAPI.target(learner::MyLearner, data) = LearnAPI.target(learner, data, frontend)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Your LearnAPI.fit implementation will then look like this:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"function LearnAPI.fit(\n\tlearner::MyLearner,\n\tobservations::Obs;\n\tverbosity=1,\n\t)\n\tX = observations.features # p x n matrix\n\ty = observations.target   # n-vector (use `Saffron(multitarget=true)` for matrix)\n\tfeature_names = observations.names\n\n\t# do stuff with `X`, `y` and `feature_names`:\n\t...\n\nend\nLearnAPI.fit(learner::MyLearner, data; kwargs...) =\n\tLearnAPI.fit(learner, LearnAPI.obs(learner, data); kwargs...)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For each KindOfProxy subtype K to be supported (e.g., Point), your LearnAPI.predict implementation(s) will look like this:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"function LearnAPI.predict(model::MyModel, :K, observations::Obs)\n\tX = observations.features # p x n matrix\n\tnames = observations.names # if really needed\n\n\t# do stuff with `X`:\n\t...\nend\nLearnAPI.predict(model::MyModel, kind_of_proxy, X) =\n\tLearnAPI.predict(model, kind_of_proxy, obs(model, X))","category":"page"},{"location":"quick_start/#Supervised-classifiers","page":"Quick start","title":"Supervised classifiers","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Supervised classifiers handling structured data can typically add the Sage front end to their LearnAPI.jl implementations.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For a supervised learner of type MyLearner, with LearnAPI.fit(::MyLearner, data) returning objects of type MyModel, make these declarations:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using LearnDataFrontEnds\nconst frontend = Sage()\n\n# both methods below return objects with abstract type `Obs`:\nLearnAPI.obs(learner::MyLearner, data) = fitobs(learner, data, frontend)\nLearnAPI.obs(model::MyModel, data) = obs(model, data, frontend)\n\n# training data deconstructors:\nLearnAPI.features(learner::MyLearner, data) = LearnAPI.features(learner, data, frontend)\nLearnAPI.target(learner::MyLearner, data) = LearnAPI.target(learner, data, frontend)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Your LearnAPI.fit implementation will then look like this:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"function LearnAPI.fit(\n    learner::MyLearner,\n    observations::Obs;\n    verbosity=1,\n    )\n    X = observations.features # p x n matrix\n    y = observations.target   # n-vector\n    decoder = observations.decoder\n    classes_seen = observatioins.classes_seen\n    feature_names = observations.names\n\n    # do stuff with `X`, `y` and `feature_names`:\n    # return a `model` object which also stores the `decoder` and/or `classes_seen` \n\t# to make them available to `predict`.\n\t...\nend\nLearnAPI.fit(learner::MyLearner, data; kwargs...) =\n    LearnAPI.fit(learner, LearnAPI.obs(learner, data); kwargs...)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For each KindOfProxy subtype K to be supported (e.g., Point), your LearnAPI.predict implementation(s) will look like this:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"function LearnAPI.predict(model::MyModel, :K, observations::Obs)\n    X = observations.features # p x n matrix\n    names = observations.names # if really needed\n\n    # Do stuff with `X` and `model` to obtain raw `predictions` (a vector of integer\n    # codes for `K = Point`, or an `n x c` matrix of probabilities for `K = Distribution`).\n    # Extract `decoder` or `classes_seen` from `model`.\n    # For `K = Point`, return `decoder.(predictions)`.\n    # For `K = Distribution`, return, say,\n    # `CategoricalDistributions.Univariate(classes_seen, predictions)`.\n    ...\nend\nLearnAPI.predict(model::MyModel, kind_of_proxy, X) = LearnAPI.predict(model,\n    kind_of_proxy, obs(model, X))","category":"page"},{"location":"quick_start/#Transformers","page":"Quick start","title":"Transformers","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Transformers can typically add the Tarragon front end to their LearnAPI.jl implementations. For simplicity, we assume below that the transformer is not static (i.e., it generalizes to new data).","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For your learners of type MyLearner, with LearnAPI.fit(::MyLearner, data) returning objects of type MyModel, make these declarations:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using LearnDataFrontEnds\nconst frontend = Tarragon()\n\n# both the following return objects with abstract type `Obs`:\nLearnAPI.obs(learner::MyLearner, data) = fitobs(learner, data, frontend)\nLearnAPI.obs(model::MyModel, X) = obs(model, data, frontend)\n\n# training data deconstructor:\nLearnAPI.features(learner::MyLearner, data) = LearnAPI.features(learner, data, frontend)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Your LearnAPI.fit implementation will then look like this:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"function LearnAPI.fit(\n\tlearner::MyLearner,\n\tobservations::Obs;\n\tverbosity=1,\n\t)\n\tx = observations.features # p x n matrix\n\tfeature_names = observations.names\n\n\t# do stuff with `x` and `feature_names`:\n\t...\nend\nLearnAPI.fit(learner::MyLearner, data; kwargs...) =\n\tLearnAPI.fit(learner, LearnAPI.obs(learner, data); kwargs...)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Your LearnAPI.transform implementation will look like this:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"function LearnAPI.transform(model::MyModel, observations::Obs)\n\tx = observations.features # p x n matrix\n\tfeature_names = observations.names # if really needed\n\n\t# do stuff with `x`:\n\t...\nend\nLearnAPI.transform(model::MyModel, X) = LearnAPI.transform(model, obs(model, X))","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"There is no need to overload LearnAPI.features for the output of obs but you still need to include :(LearnAPI.features) in the return value of LearnAPI.functions.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Saffron\nSage\nTarragon","category":"page"},{"location":"reference/#LearnDataFrontEnds.Saffron","page":"Reference","title":"LearnDataFrontEnds.Saffron","text":"Saffron(; multitarget=false, view=false)\n\nA LearnAPI.jl data front end implemented for some supervised learners, typically regressors, consuming structured data. If learner implements this front end, then data in the call LearnAPI.fit(learner, data) can take any of the following forms:\n\n(X, y), where X is a feature matrix or table and y is a target vector, matrix or table\n(T, target), where T is a table and target is a column name or a tuple (not vector!)  of column names\n(T, formula), where formula is an R-style formula, as provided by StatsModels.jl\nIn matrices, each column is an individual observation.\nSee LearnAPI.RandomAccess for what constitutes a valid table.  When  providing a formula, integer data is recast as Float64 and, by default, non-numeric  data is dummy-encoded as Float64. Refer to StatsModels.jl  documentation for details.\n\nSimilarly, if LearnAPI.learner(model) == learner, then data in the call LearnAPI.predict(model, data) or LearnAPI.transform(model, data) can take any of these forms:\n\nX, a feature matrix or table\n(T, target), where T is a table and target is a column name or tuple of column names (for exclusion from T)\n(T, formula), where formula is an R-style formula (left-hand side ignored)\n\nCheck learner documentation to see if it implements this front end.\n\nBack end API\n\nWhen a learner implements the Saffron front end, as described under \"Extended help\" below, the objects returned by LearnAPI.obs(learner, data) and LearnAPI.obs(model, data) expose array representations of the features, feature names, and target, as described under Obs.\n\nIf model records feature names (LearnAPI.feature_names has been implemented) then the front end checks that data presented to LearnAPI.predict/LearnAPI.transform has feature names (or feature count, in the case of matrices) consistent with what has been recorded in training.\n\nExtended help\n\nOptions\n\nWhen multitarget=true, the internal representation of the the target is always a matrix, even if only a single target (e.g., vector) is presented. When multitarget=false, the internal representation of the target is always a vector.\n\nWhen tables are converted to matrices (and so the roles of rows and columns are reversed) transpose is used if view=true and permutedims is used if view=false. The first option is only available for tables with transposable element types (e.g., floats).\n\nImplementation\n\nFor learners of type MyLearner, with LearnAPI.fit(::MyLearner, data) returning objects of type MyModel, implement the Saffron data front by making these declarations:\n\nusing LearnDataFrontEnds\nconst frontend = Saffron() # optionally specify `view=true` and/or `multitarget=true`\n\n# both `obs` methods return objects of abstract type `Obs`:\nLearnAPI.obs(learner::MyLearner, data) = fitobs(learner, data, frontend)\nLearnAPI.obs(model::MyModel, data) = obs(model, data, frontend)\n\n# training data deconstructors:\nLearnAPI.features(learner::MyLearner, data) = LearnAPI.features(learner, data, frontend)\nLearnAPI.target(learner::MyLearner, data) = LearnAPI.target(learner, data, frontend)\n\nYour LearnAPI.fit implementation will then look like this:\n\nfunction LearnAPI.fit(\n    learner::MyLearner,\n    observations::Obs;\n    verbosity=1,\n    )\n    X = observations.features # p x n matrix\n    y = observations.target   # n-vector or q x n matrix\n    feature_names = observations.names\n\n    # do stuff with `X`, `y` and `feature_names`:\n    ...\n\nend\nLearnAPI.fit(learner::MyLearner, data; kwargs...) =\n    LearnAPI.fit(learner, LearnAPI.obs(learner, data); kwargs...)\n\nFor each LearnAPI.KindOfProxy subtype K to be supported (e.g., Point), your LearnAPI.predict implementation(s) will look like this:\n\nfunction LearnAPI.predict(model::MyModel, :K, observations::Obs)\n    X = observations.features # p x n matrix\n    names = observations.names # if really needed\n\n    # do stuff with `X` (and `names`):\n    ...\nend\n\nwith the final declaration\n\nLearnAPI.predict(model::MyModel, kind_of_proxy, X) =\n    LearnAPI.predict(model, kind_of_proxy, obs(model, X))\n\nDon't forget to include :(LearnAPI.target) and :(LearnAPI.features) (unless learner is static) in the return value of LearnAPI.functions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LearnDataFrontEnds.Sage","page":"Reference","title":"LearnDataFrontEnds.Sage","text":"Sage(; multitarget=false, view=false, code_type=:int)\n\nA LearnAPI.jl data front end implemented for some supervised classifiers consuming structured data. If learner implements this front end, then data in the call LearnAPI.fit(learner, data) can take any of the following forms:\n\n(X, y), where X is a feature matrix or table and y is a CategoricalVector or CategoricalMatrix or table with categorical columns.\n(T, target), where T is a table and target is a column name or a tuple (not vector!)  of column names\n(T, formula), where formula is an R-style formula, as provided by StatsModels.jl\nIn matrices, each column is an individual observation.\nSee LearnAPI.RandomAccess for what constitutes a valid table.  When  providing a formula, integer data is recast as Float64 and, by default, non-numeric  data is dummy-encoded as Float64. Refer to StatsModels.jl  documentation for details.\n\nUnlike StatsModels.jl, the left-hand side of a formula (the target) is not one-hot encoded.\n\nSimilarly, if LearnAPI.learner(model) == learner, then data in the call LearnAPI.predict(model, data) or LearnAPI.transform(model, data) can take any of these forms:\n\nX, a feature matrix or table\n(T, target), where T is a table and target is a column name or tuple of column names (for exclusion from T)\n(T, formula), where formula is an R-style formula (left-hand side ignored)\n\nCheck learner documentation to see if it implements this front end.\n\nBack end API\n\nWhen a learner implements the Sage front end, as described under \"Extended help\" below, the objects returned by LearnAPI.obs(learner, data) and LearnAPI.obs(model, data) expose array representations of the features, feature names, and target, as described under Obs.\n\nIf model records feature names (LearnAPI.feature_names has been implemented) then the front end checks that data presented to LearnAPI.predict/LearnAPI.transform has feature names (or feature count, in the case of matrices) consistent with what has been recorded in training.\n\nExtended help\n\nOptions\n\nmulticlass=false: When multitarget=true, the internal representation of the the target is always a matrix, even if only a single target (e.g., vector) is presented. When multitarget=false, the internal representation of the target is always a vector.\nview=false: When tables are converted to matrices (and the roles of rows and columns are reversed) transpose is used if view=true and permutedims is used if view=false. The first option is only available for tables with transposable element types (e.g., floats).\ncode_type determines the internal representation y of the target. Possible values are:\n:small: the element type of y is the reference (code) type R <: Unsigned for the categorical array supplied by user (internal eltype for the array). Choose this to minimize memory requirements.\n:int: y has an Integer element type widen(R) <: Integer. Choose this to safeguard against arithmetic overflows if these are likely; run @doc widen for details.\n\nImplementation\n\nIf a core algorithm is happy to work with a CategoricalArray target, without integer-encoding it, consider using the Saffron frontend instead.\n\nFor learners of type MyLearner, with LearnAPI.fit(::MyLearner, data) returning objects of type MyModel, implement the Sage data front by making these declarations:\n\nusing LearnDataFrontEnds\nconst frontend = Sage() # see above for options\n\n# both `obs` methods return objects of abstract type `Obs`:\nLearnAPI.obs(learner::MyLearner, data) = fitobs(learner, data, frontend)\nLearnAPI.obs(model::MyModel, data) = obs(model, data, frontend)\n\n# training data deconstructors:\nLearnAPI.features(learner::MyLearner, data) = LearnAPI.features(learner, data, frontend)\nLearnAPI.target(learner::MyLearner, data) = LearnAPI.target(learner, data, frontend)\n\nYour LearnAPI.fit implementation will then look like this:\n\nfunction LearnAPI.fit(\n    learner::MyLearner,\n    observations::Obs;\n    verbosity=1,\n    )\n    X = observations.features # p x n matrix\n    y = observations.target   # n-vector or q x n matrix\n    decoder = observations.decoder\n    classes_seen = observations.classes_seen\n    feature_names = observations.names\n\n    # do stuff with `X`, `y` and `feature_names`:\n    # return a `model` object which also stores the `decoder` and/or\n    # `classes_seen` to make them available to `predict`.\n    ...\n\nend\nLearnAPI.fit(learner::MyLearner, data; kwargs...) =\n    LearnAPI.fit(learner, LearnAPI.obs(learner, data); kwargs...)\n\nFor each LearnAPI.KindOfProxy subtype K to be supported (e.g., Point), your LearnAPI.predict implementation(s) will look like this:\n\nfunction LearnAPI.predict(model::MyModel, :K, observations::Obs)\n    X = observations.features # p x n matrix\n    names = observations.names # if really needed\n\n    # Do stuff with `X` and `model` to obtain raw `predictions` (a vector of integer\n    # codes for `K = Point`, or an `n x c` matrix of probabilities for `K = Distribution`).\n    # Extract `decoder` or `classes_seen` from `model`.\n    # For `K = Point`, return `decoder.(predictions)`.\n    # For `K = Distribution`, return, say,\n    # `CategoricalDistributions.Univariate(classes_seen, predictions)`.\n    ...\nend\nLearnAPI.predict(model::MyModel, kind_of_proxy, X) = LearnAPI.predict(model,\n    kind_of_proxy, obs(model, X))\n\nDon't forget to include :(LearnAPI.target) and :(LearnAPI.features) (unless learner is static) in the return value of LearnAPI.functions.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LearnDataFrontEnds.Tarragon","page":"Reference","title":"LearnDataFrontEnds.Tarragon","text":"Tarragon(; view=false)\n\nA LearnAPI.jl data front end, implemented for some transformers.  If learner implements this front end, then data in the call LearnAPI.fit(learner, data) or LearnAPI.transform(model, data), where LearnAPI.learner(model) == learner, can take any of the following forms:\n\nmatrix\ntable\ntuple (T, formula), where T is a table and formula an R-style formula, as provided by StatsModels.jl (with 0 for the \"left-hand side\").\nIn matrices, each column is an individual observation.\nSee LearnAPI.RandomAccess for what constitutes a valid table.  When  providing a formula, integer data is recast as Float64 and, by default, non-numeric  data is dummy-encoded as Float64. Refer to StatsModels.jl  documentation for details.\n\nBack end API\n\nWhen a learner implements the Tarragon front end, as described under \"Extended help\" below, the objects returned by LearnAPI.obs(learner, data) and LearnAPI.obs(model, data) expose array representations of the features and feature names, as described under Obs.\n\nIf fit output records feature names (LearnAPI.feature_names has been implemented) then the front end checks that data presented to LearnAPI.transform has feature names (or feature count, in the case of matrices) consistent with what has been recorded in training.\n\nExtended help\n\nOptions\n\nWhen tables are converted to matrices (and so the roles of rows and columns are reversed) transpose is used if view=true and permutedims if view=false. The first option is only available for tables with transposable element types (e.g., floats).\n\nImplementation\n\nFor learners of type MyLearner, with LearnAPI.fit(::MyLearner, data) returning objects of type MyModel, implement the Tarragon data front by making these declarations:\n\nusing LearnDataFrontEnds\nconst frontend = Tarragon() # optionally specify `view=true`\n\n# both `obs` below return objects with abstract type `Obs`:\nLearnAPI.obs(model::MyModel, data) = obs(model, data, frontend)\nLearnAPI.obs(learner::MyLearner, data) = fitobs(learner, data, frontend)\nLearnAPI.features(learner::MyLearner, data) = LearnAPI.features(learner, data, frontend)\n\nInclude the last two lines if your learner generalizes to new data, i.e., LearnAPI.fit has data in its signature). Assuming this is the case, your LearnAPI.fit implementation will look like this:\n\nfunction LearnAPI.fit(\n    learner::MyLearner,\n    observations::Obs;\n    verbosity=1,\n    )\n    X = observations.features # p x n matrix\n    feature_names = observations.names\n\n    # do stuff with `X` and `feature_names`:\n    ...\n\nend\nLearnAPI.fit(learner::MyLearner, data; kwargs...) =\n    LearnAPI.fit(learner, LearnAPI.obs(learner, data); kwargs...)\n\nYour LearnAPI.transform implementation will look like this:\n\nfunction LearnAPI.transform(model::MyModel, observations::Obs)\n    X = observations.features # p x n matrix\n    feature_names = observations.names # if really needed\n\n    # do stuff with `X`:\n    ...\nend\nLearnAPI.transform(model::MyModel, X) = LearnAPI.transform(model, obs(model, X))\n\nRemember to include :(LearnAPI.features) in the return value of LearnAPI.functions if your learner generalizes to new data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Private-methods","page":"Reference","title":"Private methods","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"For package maintainers only.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"LearnDataFrontEnds.feature_names\nLearnDataFrontEnds.swapdims\nLearnDataFrontEnds.decoder\nLearnDataFrontEnds.decompose\nLearnDataFrontEnds.classes\nLearnDataFrontEnds.canonify","category":"page"},{"location":"reference/#LearnDataFrontEnds.feature_names","page":"Reference","title":"LearnDataFrontEnds.feature_names","text":"feature_names(model, names_apparent)\n\nPrivate method.\n\nReturn the feature names recorded in model where available, and check these agree with names_apparent (a list of names or an integer count).\n\nIn more detail:\n\nIf the names are available, meaning :(LearnAPI.feature_names) in LearnAPI.functions(learner), for learner = LearnAPI.learner(model), then:\n\nIf names_apparent is an integer, throw an exception if LearnAPI.feature_names(model) does not have this integer as length.\nOtherwise, throw an exception if LearnAPI.feature_names(model) is different from names_apparent.\n\nIf feature names are not recorded in training, then return Symbol[].\n\n\n\n\n\n","category":"function"},{"location":"reference/#LearnDataFrontEnds.swapdims","page":"Reference","title":"LearnDataFrontEnds.swapdims","text":"swapdims(A, v)\n\nPrivate method.\n\nReturn transose(A) if v == DoView(), and permutedims(A) if v == DontView().\n\n\n\n\n\n","category":"function"},{"location":"reference/#LearnDataFrontEnds.decoder","page":"Reference","title":"LearnDataFrontEnds.decoder","text":"d = decoder(x)\n\nA callable object for decoding the integer representation of a CategoricalValue sharing the same pool as the CategoricalValue x. Specifically, one has d(int(y)) == y for all y in the same pool as x.\n\njulia> v = categorical(['c', 'b', 'c', 'a'])\njulia> levelcode(v)\n4-element Array{Int64,1}:\n 3\n 2\n 3\n 1\njulia> d = decoder(v[3])\njulia> d.(levelcode.(v)) == v\ntrue\n\nWarning: There is no guarantee that levelcode.(d.(u)) == u will always holds.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LearnDataFrontEnds.decompose","page":"Reference","title":"LearnDataFrontEnds.decompose","text":"decompose(X, v, targets=())\n\nPrivate method.\n\nReturn (A, names, B) where:\n\nA is the matrix form of those columns of table X with names not in targets (a single symbol or vector thereof)\nnames is those column names not in targets\nB is the matrix form of those columns with names in targets\n\nThe columns of A and B always correspond to rows of X. However, if v == DoView() then A and B are Transposes; otherwise they are regular Matrixs.\n\nAn informative exception is thrown if target contains names that are not the names of columns of X.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LearnDataFrontEnds.classes","page":"Reference","title":"LearnDataFrontEnds.classes","text":"classes(x)\n\nPrivate method.\n\nReturn, as a CategoricalVector, all the categorical elements with the same pool as CategoricalValue x (including x), with an ordering consistent with the pool. Note that x in classes(x) is always true.\n\nNot to be confused with levels(x.pool). See the example below.\n\nAlso, overloaded for x a CategoricalArray, CategoricalPool, and for views of CategoricalArray.\n\njulia>  v = categorical(['c', 'b', 'c', 'a'])\n4-element CategoricalArrays.CategoricalArray{Char,1,UInt32}:\n 'c'\n 'b'\n 'c'\n 'a'\n\njulia> levels(v)\n3-element Array{Char,1}:\n 'a'\n 'b'\n 'c'\n\njulia> x = v[4]\nCategoricalArrays.CategoricalValue{Char,UInt32} 'a'\n\njulia> classes(x)\n3-element CategoricalArrays.CategoricalArray{Char,1,UInt32}:\n 'a'\n 'b'\n 'c'\n\njulia> levels(x.pool)\n3-element Array{Char,1}:\n 'a'\n 'b'\n 'c'\n\n\n\n\n\n","category":"function"},{"location":"reference/#LearnDataFrontEnds.canonify","page":"Reference","title":"LearnDataFrontEnds.canonify","text":"canonify(y, m)\n\nPrivate method.\n\nReturn y as a matrix, if m == Multitarget(), or as a vector otherwise.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n\n<div style=\"font-size:1.4em;font-weight:bold;\">\n  <a href=\"quick_start\"\n    style=\"color: #389826;\">Quick Start</a>           &nbsp;|&nbsp;\n  <a href=\"https://juliaai.github.io/LearnAPI.jl/dev/\"\n    style=\"color: #9558B2;\">LearnAPI.jl</a>\n\n</div>\n\n<span style=\"color: #9558B2;font-size:4.5em;\">\nLearnDataFrontEnds.jl</span>\n<br>\n<span style=\"color: #9558B2;font-size:1.6em;font-style:italic;\">\nDeveloper tool for adding canned data front ends to\n<a href=https://juliaai.github.io/LearnAPI.jl/dev/ style=\"text-decoration: underline\">LearnAPI.jl</a> implementations\n</span>\n<br>\n<br>","category":"page"},{"location":"#front_ends","page":"Home","title":"Front ends","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LearnDataFrontEnds","category":"page"},{"location":"#LearnDataFrontEnds","page":"Home","title":"LearnDataFrontEnds","text":"LearnDataFrontEnds\n\nModule providing the following commonly applicable data front ends for implementations of the LearnAPI.jl interface:\n\nSaffron: good for most supervised leaners, typically regressors, operating on structured data\nSage: good for most supervised classifiers operating on structured data\nTarragon: good for most transformers\n\nSee Obs for the corresponding back end API (the interface for the output of obs)\n\nWhy add a front end from this package?\n\nUsers get to specify data in flexible ways: ordinary arrays or most tabular formats supported by Tables.jl. Targets or multitargets can be specified separately, or by column name(s). Standard data preprocessing, such as one-hot encoding and adding higher order feature interactions, can be specified by an R-style \"formula\", as provided by StatsModels.jl.\nDevelopers can focus on core algorithm development, in which data conforms to a standard interface; see Obs.\n\n\n\n\n\n","category":"module"},{"location":"#Back-end-API","page":"Home","title":"Back end API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Obs","category":"page"},{"location":"#LearnDataFrontEnds.Obs","page":"Home","title":"LearnDataFrontEnds.Obs","text":"Obs\n\nAbstract type for all \"observations\" returned by learners implementing a front end from LearnDataFrontEnds.jl - that is, for any object returned by LearnAPI.obs(learner, data) or LearnAPI.obs(model, data), where learner implements such a front end and model is an object returned by fit(learner, ...).\n\nAny instance, observations, supports the following property access:\n\nobservations.features: size (p, n) feature matrix (n the number of observations)\nobservations.names: length p vector of feature names (as symbols)\n\nAny instance observations also implements the LearnAPI.RandomAccess interface for accessing individual observations, for purposes of resampling, for example.\n\nSpecific to Saffron and Sage\n\nAdditionally, when observations = fit(learner, data) and the Saffron(multitarget=...) or Sage(multitarget=...) front end has been implemented, one has:\n\nobservations.target: length n target vector (multitarget=false) or size (q, n) target matrix (multivariate=true); this array has the same element type as the user-provided one in the Saffron case\n\nSpecific to Sage\n\nIf Sage(multitarget=..., code_type=...) has been implemented, then observations.target has an integer element type controlled by code_type, and we additionally have:\n\nobservations.classes: A categorical vector of the ordered target classes, as actually seen in the user-supplied target, with the full pool of classes available by applying Categorical.levels to the result. The corresponding integer codes will be sort(unique(observations.target)).\nobservations.decoder: A callable function that converts an integer code back to the original CategoricalValue it represents.\n\nPass the first onto predict for making probabilistic predictions, and the second for point predictions; see Sage for details.\n\n\n\n\n\n","category":"type"}]
}
